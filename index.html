<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RayZip - Hide ZIP files in images</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #fff;
            overflow-x: hidden;
            position: relative;
        }

        #particles-js {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            padding: 30px 0;
            margin-bottom: 30px;
        }

        .logo {
            font-size: 3.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #3498db, #8e44ad);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .tagline {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 20px;
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.06);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            padding: 25px;
            margin-bottom: 30px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .glass-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
        }

        .card-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 5px;
        }

        .tab {
            padding: 12px 25px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            text-align: center;
            flex: 1;
        }

        .tab.active {
            background: rgba(52, 152, 219, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .dropzone {
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .dropzone:hover {
            border-color: rgba(52, 152, 219, 0.5);
            background: rgba(255, 255, 255, 0.03);
        }

        .dropzone i {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.7;
        }

        .dropzone-text {
            font-size: 1.2rem;
            margin-bottom: 10px;
        }

        .dropzone-subtext {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        .btn:disabled {
            background: rgba(255, 255, 255, 0.1);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        .preview-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .preview-box {
            flex: 1;
            min-width: 250px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }

        .preview-image {
            max-width: 100%;
            border-radius: 8px;
            margin-top: 10px;
            max-height: 200px;
            object-fit: contain;
        }

        .progress-container {
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 10px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .options-row {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .option-group {
            flex: 1;
            min-width: 250px;
        }

        .option-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .option-select, .option-range {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
        }

        .option-range {
            -webkit-appearance: none;
            height: 5px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            border: none;
            border-radius: 5px;
        }

        .option-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }

        .hex-container {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 15px;
            overflow-x: auto;
            font-family: monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            max-height: 400px;
            white-space: pre;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(231, 76, 60, 0.9);
            color: white;
            padding: 12px 25px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .toast.show {
            opacity: 1;
        }

        footer {
            text-align: center;
            padding: 30px 0;
            margin-top: 40px;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        @media (max-width: 768px) {
            .tabs {
                flex-direction: column;
            }
            
            .preview-container {
                flex-direction: column;
            }
            
            .options-row {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div id="particles-js"></div>
    
    <div class="container">
        <header>
            <div class="logo">RAYZIP</div>
            <div class="tagline">Hide ZIP files inside images with steganography</div>
        </header>
        
        <div class="glass-card">
            <div class="tabs">
                <div class="tab active" id="encodeTab">
                    <i class="fas fa-lock"></i> Encode
                </div>
                <div class="tab" id="decodeTab">
                    <i class="fas fa-unlock"></i> Decode
                </div>
                <div class="tab" id="hexTab">
                    <i class="fas fa-code"></i> Hex View
                </div>
            </div>
            
            <!-- Encode Panel -->
            <div class="tab-content active" id="encodePanel">
                <h2 class="card-title"><i class="fas fa-lock"></i> Hide a ZIP file in an image</h2>
                
                <div class="dropzone" id="imageDropzone">
                    <i class="fas fa-cloud-upload-alt"></i>
                    <div class="dropzone-text">Select or drop cover image</div>
                    <div class="dropzone-subtext">PNG or JPG, at least 100x100 pixels</div>
                    <input type="file" id="coverImage" accept="image/png,image/jpeg" hidden>
                </div>
                
                <div id="inputImagePreview" class="preview-container hidden">
                    <div class="preview-box">
                        <div>Cover Image Preview</div>
                        <img id="previewImage" class="preview-image">
                    </div>
                </div>
                
                <div class="dropzone" id="fileDropzone">
                    <i class="fas fa-file-archive"></i>
                    <div class="dropzone-text">Select or drop ZIP file to hide</div>
                    <div class="dropzone-subtext">Maximum size: 50MB</div>
                    <input type="file" id="zipFile" accept=".zip" hidden>
                </div>
                
                <div id="fileInfo" class="preview-container hidden">
                    <div class="preview-box">
                        <div>ZIP File Info</div>
                        <div id="fileName" class="dropzone-subtext">No file selected</div>
                        <div id="fileSize" class="dropzone-subtext">0 Bytes</div>
                    </div>
                </div>
                
                <div class="options-row">
                    <div class="option-group">
                        <label class="option-label">Output Format</label>
                        <select id="outputFormat" class="option-select">
                            <option value="png">PNG (Lossless)</option>
                            <option value="jpeg">JPEG (Smaller file)</option>
                        </select>
                    </div>
                    
                    <div class="option-group">
                        <label class="option-label">JPEG Quality <span id="qualityValue">90%</span></label>
                        <input type="range" id="jpegQuality" class="option-range" min="50" max="100" value="90">
                    </div>
                </div>
                
                <div class="progress-container hidden" id="encodeProgress">
                    <div class="progress-bar" id="encodeProgressBar"></div>
                    <div class="progress-text" id="encodeStatus">Starting...</div>
                </div>
                
                <div style="display: flex; gap: 15px; margin-top: 20px;">
                    <button id="encodeButton" class="btn" disabled>
                        <i class="fas fa-cog"></i> Encode File
                    </button>
                    <button id="resetButton" class="btn btn-secondary">
                        <i class="fas fa-redo"></i> Reset
                    </button>
                </div>
                
                <div id="encodeOutput" class="preview-container hidden">
                    <div class="preview-box">
                        <div>Encoded Image</div>
                        <img id="resultImage" class="preview-image">
                        <button id="downloadButton" class="btn" style="margin-top: 15px;">
                            <i class="fas fa-download"></i> Download
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Decode Panel -->
            <div class="tab-content" id="decodePanel">
                <h2 class="card-title"><i class="fas fa-unlock"></i> Extract a hidden ZIP file</h2>
                
                <div class="dropzone" id="decodeDropzone">
                    <i class="fas fa-cloud-upload-alt"></i>
                    <div class="dropzone-text">Select or drop encoded image</div>
                    <div class="dropzone-subtext">Image with hidden ZIP file</div>
                    <input type="file" id="encodedImage" accept="image/png,image/jpeg" hidden>
                </div>
                
                <div id="decodePreview" class="preview-container hidden">
                    <div class="preview-box">
                        <div>Encoded Image Preview</div>
                        <img id="decodePreviewImage" class="preview-image">
                    </div>
                </div>
                
                <div class="progress-container hidden" id="decodeProgress">
                    <div class="progress-bar" id="decodeProgressBar"></div>
                    <div class="progress-text" id="decodeStatus">Starting...</div>
                </div>
                
                <button id="decodeButton" class="btn" disabled style="margin-top: 20px;">
                    <i class="fas fa-cog"></i> Decode File
                </button>
                
                <div id="decodeOutput" class="preview-container hidden">
                    <div class="preview-box">
                        <div>Extracted File</div>
                        <div id="extractedFileName" class="dropzone-subtext">hidden_file.zip</div>
                        <div id="extractedFileSize" class="dropzone-subtext">0 Bytes</div>
                        <button id="downloadExtractedButton" class="btn" style="margin-top: 15px;">
                            <i class="fas fa-download"></i> Download
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Hex Panel -->
            <div class="tab-content" id="hexPanel">
                <h2 class="card-title"><i class="fas fa-code"></i> Inspect Image Hex Data</h2>
                
                <div class="dropzone" id="hexDropzone">
                    <i class="fas fa-cloud-upload-alt"></i>
                    <div class="dropzone-text">Select or drop image to inspect</div>
                    <div class="dropzone-subtext">View raw hex data of any image</div>
                    <input type="file" id="hexImage" accept="image/png,image/jpeg" hidden>
                </div>
                
                <div class="option-group" style="margin: 20px 0;">
                    <label class="option-label">Bytes to Display</label>
                    <select id="hexLimit" class="option-select">
                        <option value="256">256 Bytes</option>
                        <option value="512">512 Bytes</option>
                        <option value="1024" selected>1 KB</option>
                        <option value="2048">2 KB</option>
                        <option value="5120">5 KB</option>
                    </select>
                </div>
                
                <div id="hexOutput" class="hidden">
                    <div class="hex-container" id="hexContent"></div>
                </div>
            </div>
        </div>
        
        <div class="toast hidden" id="toast"></div>
        
        <footer>
            <p>RayZip - Steganography Tool | Secure your files inside images</p>
            <p>Note: This tool processes files entirely in your browser. Files are not uploaded to any server.</p>
        </footer>
    </div>

    <!-- Include particles.js -->
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    
    <script>
        // Initialize particles.js
        document.addEventListener('DOMContentLoaded', function() {
            particlesJS('particles-js', {
                particles: {
                    number: { value: 80, density: { enable: true, value_area: 800 } },
                    color: { value: "#ffffff" },
                    shape: { type: "circle" },
                    opacity: { value: 0.2, random: true },
                    size: { value: 3, random: true },
                    line_linked: {
                        enable: true,
                        distance: 150,
                        color: "#ffffff",
                        opacity: 0.1,
                        width: 1
                    },
                    move: {
                        enable: true,
                        speed: 1,
                        direction: "none",
                        random: true,
                        straight: false,
                        out_mode: "out",
                        bounce: false
                    }
                },
                interactivity: {
                    detect_on: "canvas",
                    events: {
                        onhover: { enable: true, mode: "grab" },
                        onclick: { enable: true, mode: "push" },
                        resize: true
                    }
                },
                retina_detect: true
            });
            
            // Initialize the app
            initializeApp();
        });
        
        // Tab management
        function initializeTabs() {
            const tabs = ['encode', 'decode', 'hex'];
            
            tabs.forEach(tabName => {
                const tabElement = document.getElementById(`${tabName}Tab`);
                if (tabElement) {
                    tabElement.addEventListener('click', () => switchTab(tabName));
                }
            });
        }

        function switchTab(tabName) {
            const tabs = ['encode', 'decode', 'hex'];
            
            // Hide all panels and deactivate all tabs
            tabs.forEach(tab => {
                const panel = document.getElementById(`${tab}Panel`);
                const tabEl = document.getElementById(`${tab}Tab`);
                
                if (panel) panel.classList.remove('active');
                if (tabEl) tabEl.classList.remove('active');
            });
            
            // Show selected panel and activate tab
            const selectedPanel = document.getElementById(`${tabName}Panel`);
            const selectedTab = document.getElementById(`${tabName}Tab`);
            
            if (selectedPanel) selectedPanel.classList.add('active');
            if (selectedTab) selectedTab.classList.add('active');
        }

        // Configuration constants
        const CONFIG = {
            HEADER_SIGNATURE: "RAYZIP",
            HEADER_SIZE: 32,
            MAX_FILE_SIZE: 50 * 1024 * 1024, // 50MB limit
            MIN_IMAGE_DIMENSION: 100,
            SUPPORTED_IMAGE_TYPES: ['image/png', 'image/jpeg', 'image/jpg'],
            SUPPORTED_FILE_TYPES: ['.zip'],
            PROGRESS_UPDATE_INTERVAL: 1000, // bytes
            ANIMATION_DELAY: 100 // ms
        };

        // State management
        const state = {
            coverImageFile: null,
            zipFile: null,
            encodedImageFile: null,
            hexImageFile: null,
            isProcessing: false,
            objectUrls: {}
        };

        // Utility functions
        const utils = {
            // Debounce function to prevent rapid successive calls
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },

            // Safe DOM element getter
            getElement(id) {
                const element = document.getElementById(id);
                if (!element) {
                    console.warn(`Element with id '${id}' not found`);
                }
                return element;
            },

            // Enhanced file size formatter
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                if (typeof bytes !== 'number' || bytes < 0) return 'Invalid size';
                
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            },

            // Validate image file
            validateImageFile(file) {
                if (!file) {
                    throw new Error('No file provided');
                }
                
                if (!CONFIG.SUPPORTED_IMAGE_TYPES.includes(file.type)) {
                    throw new Error(`Unsupported image format. Please use: ${CONFIG.SUPPORTED_IMAGE_TYPES.join(', ')}`);
                }
                
                if (file.size > CONFIG.MAX_FILE_SIZE) {
                    throw new Error(`Image file too large. Maximum size: ${utils.formatFileSize(CONFIG.MAX_FILE_SIZE)}`);
                }
                
                return true;
            },

            // Validate ZIP file
            validateZipFile(file) {
                if (!file) {
                    throw new Error('No file provided');
                }
                
                if (!file.name.toLowerCase().endsWith('.zip')) {
                    throw new Error('Please select a valid ZIP file');
                }
                
                if (file.size > CONFIG.MAX_FILE_SIZE) {
                    throw new Error(`ZIP file too large. Maximum size: ${utils.formatFileSize(CONFIG.MAX_FILE_SIZE)}`);
                }
                
                return true;
            },

            // Enhanced error display with auto-dismiss
            showError(message, duration = 5000) {
                console.error('Error:', message);
                const toast = utils.getElement('toast');
                if (!toast) return;
                
                toast.textContent = message;
                toast.classList.remove('hidden');
                toast.classList.add('show');
                
                // Clear any existing timeout
                if (toast.timeoutId) {
                    clearTimeout(toast.timeoutId);
                }
                
                toast.timeoutId = setTimeout(() => {
                    toast.classList.remove('show');
                    toast.classList.add('hidden');
                }, duration);
            },

            // Safe async operation wrapper
            async safeAsync(operation, errorMessage) {
                try {
                    return await operation();
                } catch (error) {
                    console.error(errorMessage, error);
                    utils.showError(`${errorMessage}: ${error.message}`);
                    throw error;
                }
            }
        };

        // Enhanced drag and drop handlers
        function initializeDragAndDrop() {
            const dropzones = [
                { id: 'imageDropzone', inputId: 'coverImage', handler: handleCoverImageSelect, validator: 'image' },
                { id: 'fileDropzone', inputId: 'zipFile', handler: handleZipFileSelect, validator: 'zip' },
                { id: 'decodeDropzone', inputId: 'encodedImage', handler: handleEncodedImageSelect, validator: 'image' },
                { id: 'hexDropzone', inputId: 'hexImage', handler: handleHexImageSelect, validator: 'image' }
            ];

            dropzones.forEach(({ id, inputId, handler, validator }) => {
                const dropzone = utils.getElement(id);
                const input = utils.getElement(inputId);
                
                if (!dropzone || !input) return;

                // Click to select file
                dropzone.addEventListener('click', () => input.click());
                input.addEventListener('change', handler);

                // Drag and drop events
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    dropzone.addEventListener(eventName, preventDefaults, false);
                });

                ['dragenter', 'dragover'].forEach(eventName => {
                    dropzone.addEventListener(eventName, (e) => highlight(e, dropzone), false);
                });

                ['dragleave', 'drop'].forEach(eventName => {
                    dropzone.addEventListener(eventName, (e) => unhighlight(e, dropzone), false);
                });

                dropzone.addEventListener('drop', (e) => handleDrop(e, validator, handler), false);
            });
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function highlight(e, element) {
            element.classList.add('active');
        }

        function unhighlight(e, element) {
            element.classList.remove('active');
        }

        function handleDrop(e, validator, handler) {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length === 0) return;
            
            const file = files[0];
            
            try {
                if (validator === 'image' && !file.type.match('image.*')) {
                    throw new Error('Please drop a valid image file');
                }
                if (validator === 'zip' && !file.name.toLowerCase().endsWith('.zip')) {
                    throw new Error('Please drop a valid ZIP file');
                }
                
                handler({ target: { files: [file] } });
            } catch (error) {
                utils.showError(error.message);
            }
        }

        // Enhanced file handlers
        function handleCoverImageSelect(e) {
            if (state.isProcessing) {
                utils.showError('Please wait for current operation to complete');
                return;
            }

            try {
                const file = e.target.files[0];
                if (!file) return;

                utils.validateImageFile(file);
                state.coverImageFile = file;

                const reader = new FileReader();
                reader.onerror = () => utils.showError('Failed to read image file');
                reader.onload = (event) => {
                    const img = new Image();
                    img.onerror = () => utils.showError('Invalid image file');
                    img.onload = () => {
                        // Validate minimum dimensions
                        if (img.width < CONFIG.MIN_IMAGE_DIMENSION || img.height < CONFIG.MIN_IMAGE_DIMENSION) {
                            utils.showError(`Image too small. Minimum dimensions: ${CONFIG.MIN_IMAGE_DIMENSION}x${CONFIG.MIN_IMAGE_DIMENSION}px`);
                            return;
                        }

                        const preview = utils.getElement('previewImage');
                        const previewContainer = utils.getElement('inputImagePreview');
                        
                        if (preview && previewContainer) {
                            preview.src = event.target.result;
                            previewContainer.classList.remove('hidden');
                        }
                        
                        checkEncodeReady();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);

            } catch (error) {
                utils.showError(error.message);
                e.target.value = ''; // Clear invalid selection
            }
        }

        function handleZipFileSelect(e) {
            if (state.isProcessing) {
                utils.showError('Please wait for current operation to complete');
                return;
            }

            try {
                const file = e.target.files[0];
                if (!file) return;

                utils.validateZipFile(file);
                state.zipFile = file;

                // Update file info display
                const fileName = utils.getElement('fileName');
                const fileSize = utils.getElement('fileSize');
                const fileInfo = utils.getElement('fileInfo');
                
                if (fileName) fileName.textContent = file.name;
                if (fileSize) fileSize.textContent = utils.formatFileSize(file.size);
                if (fileInfo) fileInfo.classList.remove('hidden');

                checkEncodeReady();

            } catch (error) {
                utils.showError(error.message);
                e.target.value = ''; // Clear invalid selection
            }
        }

        function handleEncodedImageSelect(e) {
            if (state.isProcessing) {
                utils.showError('Please wait for current operation to complete');
                return;
            }

            try {
                const file = e.target.files[0];
                if (!file) return;

                utils.validateImageFile(file);
                state.encodedImageFile = file;

                const reader = new FileReader();
                reader.onerror = () => utils.showError('Failed to read encoded image');
                reader.onload = (event) => {
                    const preview = utils.getElement('decodePreviewImage');
                    const previewContainer = utils.getElement('decodePreview');
                    
                    if (preview && previewContainer) {
                        preview.src = event.target.result;
                        previewContainer.classList.remove('hidden');
                    }

                    const decodeButton = utils.getElement('decodeButton');
                    if (decodeButton) decodeButton.disabled = false;
                };
                reader.readAsDataURL(file);

            } catch (error) {
                utils.showError(error.message);
                e.target.value = '';
            }
        }

        function handleHexImageSelect(e) {
            try {
                const file = e.target.files[0];
                if (!file) return;

                utils.validateImageFile(file);
                state.hexImageFile = file;

                const reader = new FileReader();
                reader.onerror = () => utils.showError('Failed to read image for hex view');
                reader.onload = (event) => {
                    const arrayBuffer = event.target.result;
                    const uint8Array = new Uint8Array(arrayBuffer);
                    updateHexView(uint8Array);
                };
                reader.readAsArrayBuffer(file);

            } catch (error) {
                utils.showError(error.message);
                e.target.value = '';
            }
        }

        function checkEncodeReady() {
            const encodeButton = utils.getElement('encodeButton');
            if (!encodeButton) return;
            
            encodeButton.disabled = !(state.coverImageFile && state.zipFile) || state.isProcessing;
        }

        // Enhanced encoding with better progress tracking
        async function encodeFile() {
            if (!state.coverImageFile || !state.zipFile || state.isProcessing) return;

            state.isProcessing = true;
            const encodeButton = utils.getElement('encodeButton');
            if (encodeButton) encodeButton.disabled = true;

            try {
                await utils.safeAsync(async () => {
                    const coverData = await readFileAsDataURL(state.coverImageFile);
                    const zipData = await readFileAsArrayBuffer(state.zipFile);
                    
                    const img = await loadImage(coverData);
                    
                    // Validate image can hold the ZIP file
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const totalBits = imageData.data.length * 3; // RGB channels only
                    const availableBytes = Math.floor(totalBits / 8);
                    const zipArray = new Uint8Array(zipData);

                    if (zipArray.length > availableBytes - CONFIG.HEADER_SIZE) {
                        throw new Error(`ZIP file too large for this image. Available space: ${utils.formatFileSize(availableBytes - CONFIG.HEADER_SIZE)}, Required: ${utils.formatFileSize(zipArray.length)}`);
                    }

                    // Show progress
                    const progressContainer = utils.getElement('encodeProgress');
                    if (progressContainer) progressContainer.classList.remove('hidden');

                    await encodeImageWithZip(canvas, imageData, zipArray);
                }, 'Encoding failed');

            } catch (error) {
                // Error already handled in safeAsync
            } finally {
                state.isProcessing = false;
                checkEncodeReady();
            }
        }

        async function encodeImageWithZip(canvas, imageData, zipArray) {
            return new Promise((resolve, reject) => {
                try {
                    const pixels = imageData.data;
                    const zipLength = zipArray.length;
                    const outputFormat = utils.getElement('outputFormat')?.value || 'png';
                    const jpegQuality = parseInt(utils.getElement('jpegQuality')?.value || '90') / 100;

                    // Create header with validation
                    const header = new Uint8Array(CONFIG.HEADER_SIZE);
                    const headerStr = CONFIG.HEADER_SIGNATURE;
                    
                    for (let i = 0; i < headerStr.length; i++) {
                        header[i] = headerStr.charCodeAt(i);
                    }
                    
                    // Store file size in little-endian format with bounds checking
                    if (zipLength > 0xFFFFFFFF) {
                        throw new Error('File too large to encode');
                    }
                    
                    header[6] = zipLength & 0xff;
                    header[7] = (zipLength >> 8) & 0xff;
                    header[8] = (zipLength >> 16) & 0xff;
                    header[9] = (zipLength >> 24) & 0xff;
                    
                    const dataToHide = new Uint8Array(header.length + zipLength);
                    dataToHide.set(header);
                    dataToHide.set(zipArray, header.length);
                    
                    // Encode with progress updates
                    let dataIndex = 0;
                    let bitIndex = 0;
                    let currentByte = dataToHide[dataIndex];
                    
                    const totalPixelsNeeded = Math.ceil(dataToHide.length * 8 / 3);
                    const progressStep = Math.max(1, Math.floor(totalPixelsNeeded / 100));
                    let pixelsProcessed = 0;
                    
                    const updateProgress = (progress, status) => {
                        const progressBar = utils.getElement('encodeProgressBar');
                        const statusText = utils.getElement('encodeStatus');
                        if (progressBar) progressBar.style.width = `${progress}%`;
                        if (statusText) statusText.textContent = status;
                    };

                    // Process pixels in chunks to prevent blocking
                    const processChunk = (startIndex) => {
                        const chunkSize = 10000; // Process 10k pixels at a time
                        const endIndex = Math.min(startIndex + chunkSize, pixels.length);
                        
                        for (let i = startIndex; i < endIndex && dataIndex < dataToHide.length; i += 4) {
                            for (let j = 0; j < 3; j++) {
                                if (dataIndex >= dataToHide.length) break;
                                
                                const bit = (currentByte >> bitIndex) & 1;
                                pixels[i + j] = (pixels[i + j] & 0xfe) | bit;
                                
                                bitIndex++;
                                if (bitIndex >= 8) {
                                    bitIndex = 0;
                                    dataIndex++;
                                    if (dataIndex < dataToHide.length) {
                                        currentByte = dataToHide[dataIndex];
                                    }
                                }
                            }
                            
                            pixelsProcessed++;
                            if (pixelsProcessed % progressStep === 0) {
                                const progress = Math.min(99, Math.floor(pixelsProcessed / totalPixelsNeeded * 100));
                                updateProgress(progress, `Encoding... ${progress}%`);
                            }
                        }
                        
                        if (endIndex < pixels.length && dataIndex < dataToHide.length) {
                            setTimeout(() => processChunk(endIndex), 10);
                        } else {
                            // Encoding complete
                            const ctx = canvas.getContext('2d');
                            ctx.putImageData(imageData, 0, 0);
                            
                            updateProgress(100, 'Encoding complete!');
                            
                            setTimeout(() => {
                                try {
                                    const resultImage = utils.getElement('resultImage');
                                    const encodeOutput = utils.getElement('encodeOutput');
                                    
                                    if (resultImage && encodeOutput) {
                                        if (outputFormat === 'png') {
                                            resultImage.src = canvas.toDataURL('image/png');
                                        } else {
                                            resultImage.src = canvas.toDataURL('image/jpeg', jpegQuality);
                                        }
                                        
                                        encodeOutput.classList.remove('hidden');
                                        
                                        const downloadButton = utils.getElement('downloadButton');
                                        if (downloadButton) {
                                            downloadButton.onclick = () => {
                                                const link = document.createElement('a');
                                                link.download = `hidden_${state.coverImageFile.name.split('.')[0]}.${outputFormat}`;
                                                link.href = resultImage.src;
                                                link.click();
                                            };
                                        }
                                    }
                                    resolve();
                                } catch (error) {
                                    reject(error);
                                }
                            }, 500);
                        }
                    };
                    
                    updateProgress(0, 'Starting encoding...');
                    setTimeout(() => processChunk(0), CONFIG.ANIMATION_DELAY);
                    
                } catch (error) {
                    reject(error);
                }
            });
        }

        // Enhanced decoding with better error handling
        async function decodeFile() {
            if (!state.encodedImageFile || state.isProcessing) return;

            state.isProcessing = true;
            const decodeButton = utils.getElement('decodeButton');
            if (decodeButton) decodeButton.disabled = true;

            try {
                await utils.safeAsync(async () => {
                    const imageData = await readFileAsDataURL(state.encodedImageFile);
                    const img = await loadImage(imageData);
                    
                    const progressContainer = utils.getElement('decodeProgress');
                    if (progressContainer) progressContainer.classList.remove('hidden');

                    await extractHiddenFile(img);
                }, 'Decoding failed');

            } catch (error) {
                // Error already handled in safeAsync
            } finally {
                state.isProcessing = false;
                const decodeButton = utils.getElement('decodeButton');
                if (decodeButton) decodeButton.disabled = false;
            }
        }

        async function extractHiddenFile(img) {
            return new Promise((resolve, reject) => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const pixels = imageData.data;
                    
                    const updateProgress = (progress, status) => {
                        const progressBar = utils.getElement('decodeProgressBar');
                        const statusText = utils.getElement('decodeStatus');
                        if (progressBar) progressBar.style.width = `${progress}%`;
                        if (statusText) statusText.textContent = status;
                    };

                    updateProgress(5, 'Reading header...');
                    
                    // Extract header
                    const header = new Uint8Array(CONFIG.HEADER_SIZE);
                    let headerIndex = 0;
                    let bitIndex = 0;
                    
                    for (let i = 0; i < pixels.length && headerIndex < CONFIG.HEADER_SIZE; i += 4) {
                        for (let j = 0; j < 3 && headerIndex < CONFIG.HEADER_SIZE; j++) {
                            const bit = pixels[i + j] & 1;
                            header[headerIndex] = (header[headerIndex] >> 1) | (bit << 7);
                            
                            bitIndex++;
                            if (bitIndex >= 8) {
                                bitIndex = 0;
                                headerIndex++;
                            }
                        }
                    }
                    
                    updateProgress(15, 'Validating header...');
                    
                    // Validate header signature
                    const headerStr = String.fromCharCode(...header.slice(0, CONFIG.HEADER_SIGNATURE.length));
                    if (headerStr !== CONFIG.HEADER_SIGNATURE) {
                        throw new Error('No hidden file found or invalid signature');
                    }
                    
                    // Extract file size with bounds checking
                    const fileSize = header[6] | (header[7] << 8) | (header[8] << 16) | (header[9] << 24);
                    
                    if (fileSize <= 0 || fileSize > CONFIG.MAX_FILE_SIZE) {
                        throw new Error(`Invalid file size: ${utils.formatFileSize(fileSize)}`);
                    }
                    
                    updateProgress(25, 'Extracting data...');
                    
                    const fileData = new Uint8Array(fileSize);
                    let dataIndex = 0;
                    bitIndex = 0;
                    let currentByte = 0;
                    
                    const startPixel = Math.ceil((CONFIG.HEADER_SIZE * 8) / 3);
                    const chunkSize = 10000;
                    
                    const processChunk = (startIndex) => {
                        const endIndex = Math.min(startIndex + chunkSize, pixels.length);
                        
                        for (let i = startIndex; i < endIndex && dataIndex < fileSize; i += 4) {
                            for (let j = 0; j < 3 && dataIndex < fileSize; j++) {
                                const bit = pixels[i + j] & 1;
                                currentByte = (currentByte >> 1) | (bit << 7);
                                
                                bitIndex++;
                                if (bitIndex >= 8) {
                                    fileData[dataIndex] = currentByte;
                                    bitIndex = 0;
                                    currentByte = 0;
                                    dataIndex++;
                                    
                                    if (dataIndex % CONFIG.PROGRESS_UPDATE_INTERVAL === 0 || dataIndex === fileSize) {
                                        const progress = Math.min(95, 25 + Math.floor(dataIndex / fileSize * 70));
                                        updateProgress(progress, `Extracting... ${Math.floor(dataIndex / fileSize * 100)}%`);
                                    }
                                }
                            }
                        }
                        
                        if (endIndex < pixels.length && dataIndex < fileSize) {
                            setTimeout(() => processChunk(endIndex), 10);
                        } else {
                            // Validate ZIP file signature
                            if (fileData.length < 4 || 
                                fileData[0] !== 0x50 || fileData[1] !== 0x4B || 
                                fileData[2] !== 0x03 || fileData[3] !== 0x04) {
                                reject(new Error('Extracted data is not a valid ZIP file'));
                                return;
                            }
                            
                            updateProgress(100, 'Extraction complete!');
                            
                            // Create download
                            const blob = new Blob([fileData], { type: 'application/zip' });
                            const url = URL.createObjectURL(blob);
                            
                            const fileNameEl = utils.getElement('extractedFileName');
                            const fileSizeEl = utils.getElement('extractedFileSize');
                            const decodeOutput = utils.getElement('decodeOutput');
                            
                            if (fileNameEl) fileNameEl.textContent = 'hidden_file.zip';
                            if (fileSizeEl) fileSizeEl.textContent = utils.formatFileSize(fileSize);
                            if (decodeOutput) decodeOutput.classList.remove('hidden');
                            
                            const downloadButton = utils.getElement('downloadExtractedButton');
                            if (downloadButton) {
                                downloadButton.onclick = () => {
                                    const link = document.createElement('a');
                                    link.download = 'hidden_file.zip';
                                    link.href = url;
                                    link.click();
                                };
                            }
                            
                            resolve();
                        }
                    };
                    
                    setTimeout(() => processChunk(startPixel * 4), CONFIG.ANIMATION_DELAY);
                    
                } catch (error) {
                    reject(error);
                }
            });
        }

        // Enhanced hex view with performance optimization
        function updateHexView(uint8Array) {
            const limit = Math.min(parseInt(utils.getElement('hexLimit')?.value || '1000'), uint8Array.length);
            const limitedArray = uint8Array.slice(0, limit);
            
            const lines = [];
            
            for (let i = 0; i < limitedArray.length; i += 16) {
                const chunk = limitedArray.slice(i, Math.min(i + 16, limitedArray.length));
                
                // Offset
                const offset = i.toString(16).padStart(8, '0').toUpperCase();
                
                // Hex bytes
                const hex = Array.from(chunk)
                    .map(byte => byte.toString(16).padStart(2, '0').toUpperCase())
                    .join(' ')
                    .padEnd(47, ' '); // 16 bytes * 2 chars + 15 spaces = 47 chars
                
                // ASCII representation
                const ascii = Array.from(chunk)
                    .map(byte => (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.')
                    .join('');
                
                lines.push(`${offset}  ${hex}  ${ascii}`);
            }
            
            const hexContent = utils.getElement('hexContent');
            const hexOutput = utils.getElement('hexOutput');
            
            if (hexContent) hexContent.textContent = lines.join('\n');
            if (hexOutput) hexOutput.classList.remove('hidden');
        }

        // Helper functions for file operations
        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.onload = (e) => resolve(e.target.result);
                reader.readAsDataURL(file);
            });
        }

        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.onload = (e) => resolve(e.target.result);
                reader.readAsArrayBuffer(file);
            });
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onerror = () => reject(new Error('Failed to load image'));
                img.onload = () => resolve(img);
                img.src = src;
            });
        }

        // Reset functionality
        function resetEncoder() {
            if (state.isProcessing) {
                utils.showError('Cannot reset while operation is in progress');
                return;
            }
            
            state.coverImageFile = null;
            state.zipFile = null;
            
            // Clear form inputs
            const inputs = ['coverImage', 'zipFile'];
            inputs.forEach(id => {
                const input = utils.getElement(id);
                if (input) input.value = '';
            });
            
            // Hide UI elements
            const hideElements = ['inputImagePreview', 'fileInfo', 'encodeOutput', 'encodeProgress'];
            hideElements.forEach(id => {
                const el = utils.getElement(id);
                if (el) el.classList.add('hidden');
            });
            
            checkEncodeReady();
        }

        // Initialize quality slider
        function initializeQualitySlider() {
            const qualitySlider = utils.getElement('jpegQuality');
            const qualityValue = utils.getElement('qualityValue');
            const outputFormat = utils.getElement('outputFormat');
            
            if (qualitySlider && qualityValue) {
                qualityValue.textContent = `${qualitySlider.value}%`;
                qualitySlider.addEventListener('input', utils.debounce((e) => {
                    qualityValue.textContent = `${e.target.value}%`;
                }, 100));
            }
            
            if (outputFormat && qualitySlider) {
                outputFormat.addEventListener('change', (e) => {
                    qualitySlider.disabled = e.target.value !== 'jpeg';
                });
            }
        }

        // Initialize hex limit listener
        function initializeHexLimit() {
            const hexLimitSelect = utils.getElement('hexLimit');
            if (hexLimitSelect) {
                hexLimitSelect.addEventListener('change', () => {
                    if (state.hexImageFile) {
                        utils.safeAsync(async () => {
                            const arrayBuffer = await readFileAsArrayBuffer(state.hexImageFile);
                            const uint8Array = new Uint8Array(arrayBuffer);
                            updateHexView(uint8Array);
                        }, 'Failed to update hex view');
                    }
                });
            }
        }

        // Initialize all buttons
        function initializeButtons() {
            const encodeBtn = utils.getElement('encodeButton');
            const decodeBtn = utils.getElement('decodeButton');
            const resetBtn = utils.getElement('resetButton');
            
            if (encodeBtn) {
                encodeBtn.addEventListener('click', () => {
                    utils.safeAsync(encodeFile, 'Encoding failed');
                });
            }

            if (decodeBtn) {
                decodeBtn.addEventListener('click', () => {
                    utils.safeAsync(decodeFile, 'Decoding failed');
                });
            }

            if (resetBtn) {
                resetBtn.addEventListener('click', resetEncoder);
            }
        }

        // Final initialization
        function initializeApp() {
            try {
                // Initialize tabs
                initializeTabs();
                
                // Set default tab
                switchTab('encode');

                // Initialize drag and drop
                initializeDragAndDrop();

                // Initialize quality slider
                initializeQualitySlider();

                // Initialize hex limit
                initializeHexLimit();

                // Initialize buttons
                initializeButtons();

                // Set up initial button states
                const encodeBtn = utils.getElement('encodeButton');
                const decodeBtn = utils.getElement('decodeButton');
                
                if (encodeBtn) encodeBtn.disabled = true;
                if (decodeBtn) decodeBtn.disabled = true;

                // Initialize output format
                const outputFormatSelect = utils.getElement('outputFormat');
                if (outputFormatSelect && outputFormatSelect.value === 'png') {
                    const jpegQualitySlider = utils.getElement('jpegQuality');
                    if (jpegQualitySlider) jpegQualitySlider.disabled = true;
                }

                console.log('RayZip application initialized successfully');

            } catch (error) {
                console.error('Initialization error:', error);
                utils.showError('Failed to initialize application. Please refresh the page.');
            }
        }
    </script>
</body>
</html>
